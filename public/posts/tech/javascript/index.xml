<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vinilla JavaScript📒 on Nic Tian</title>
    <link>http://blog.nekolas.cafe/posts/tech/javascript/</link>
    <description>Recent content in Vinilla JavaScript📒 on Nic Tian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Jul 2022 17:00:00 +0800</lastBuildDate><atom:link href="http://blog.nekolas.cafe/posts/tech/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript ES6 Module 模块导入/导出</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/js-es-module/</link>
      <pubDate>Mon, 04 Jul 2022 17:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/js-es-module/</guid>
      <description>貌似在18年，原生JavaScript终于实现了自带模块的导出导入功能。
它有什么用呢？
比如我上一个demo，需要一个将两个对象深层合并的方法。
我可以选择直接写在组件里，但更直观的方法是把方法封装在 ./src/components/megreObj.js 中，更易于查看。
组件内如何调用另一个文件里的方法呢？
Module Export/Import come to rescue!
应用模块到你的 HTML 首先，你需要把 type=&amp;quot;module&amp;quot;放到 &amp;lt;script&amp;gt;标签中，来声明这个脚本是一个模块，不然HTML是不会渲染的，还会报错：
&amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; Export export有两种方式:
 export default  每个模块只能有一个默认导出 引入时不需要 { } 包裹   export  可以有多个 引入时需要 { } 包裹    例子：
// 默认导出 export default class user { constructor(name, age) { this.name = name; this.age = age } } // 普通导出 export function printName(user) { console.log(`username is ${user.</description>
    </item>
    
    <item>
      <title>用简单的方式理解JavaScript Promise</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/js-promise/</link>
      <pubDate>Sun, 03 Jul 2022 13:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/js-promise/</guid>
      <description>众所周知，在JavaScript的世界中，代码是单线程执行的。
这样设计的后果是容易阻塞随后的脚本运行。
下面的例子中，要等待doNotDoThis()打印完0 ~ 100000，才能接着打印console.log(&#39;Second log&#39;)，
function doNotDoThis() { for (let i = 0; i &amp;lt; 100000; i++) { console.log(i); } } // 立即打印 console.log(&amp;#39;First log&amp;#39;) // Don&amp;#39;t do this. doNotDoThis(); // 然后立即打印 console.log(&amp;#39;Second log&amp;#39;) 只要我们网络冲浪，访问不同的网址，就需要向各个服务器发送HTTP请求，然后等待返回数据。
但是呢，服务器不可能立即返回数据到客户端。
但如果按照单线程的运行方式，服务器返回数据之前，浏览器会处于一种卡死状态，这会让我们冲浪的体验极差。
于是就有了一些解决方案。
异步请求1.0 ———— 古早的Callback 我们可以给处理函数传递一个回调函数来处理回调结果。
我们常见的定时器setTimeout()就是回调函数：
const callball = () =&amp;gt; { console.log(&amp;#34;I&amp;#39;m a callback.&amp;#34;) } function isCallback() { setTimeout(callback, 2000) } isCallback() //2秒后打印： I&amp;#39;m a callback. 但要是回调函数非常复杂，嵌套好几个回调函数，就会造成回调地狱
// a函数执行b，b函数执行c，c函数打印最终结果 a(function (resultA) { b(resultA, function (resultB) { caches(resultB, function (resultC) { console.</description>
    </item>
    
    <item>
      <title>如何浅合并一下 JavaScript 对象（其实希望深拷贝）</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/js-object-merge/</link>
      <pubDate>Thu, 23 Jun 2022 15:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/js-object-merge/</guid>
      <description>由于业务需求，本人需要将两个对象进行合并。 对象层级较浅的情况，可以使用 ES6 ...语法，解构赋值，或 Object.assign() 快速合并；但对象里有子对象嵌套时，前两招就不好使了。要么使用第三方库，如 loadash 的 _.merge() 或 jQuery 的 $.extend() 方法，要么自己封装一个函数。
... 拷贝对象属性 使用扩展运算符 {...obj} 克隆或者拷贝对象的属性：
const obj1 = { name: &amp;#34;Nic&amp;#34; } const clonedObj = { ...obj1 } console.log(clonedObj) // { name: &amp;#34;Nic&amp;#34; } ... 合并对象 使用扩展运算符 {...obj} 合并两个对象，可以看到，扩展运算符内部的同名属性会被覆盖掉：
const obj1 = { a: 1 } const obj2 = { a: 2, b: 3 } const obj3 = { a: 3, b: 4, c: 5 } const obj = { .</description>
    </item>
    
    <item>
      <title>codewars练习</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/codewars/</link>
      <pubDate>Sat, 21 May 2022 14:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/codewars/</guid>
      <description>开个帖子记录一下解题和方法。
Break camelCase Details
 Complete the solution so that the function will break up camel casing, using a space between words.
 Example
&amp;quot;camelCasing&amp;quot; =&amp;gt; &amp;quot;camel Casing&amp;quot;&amp;quot;identifier&amp;quot; =&amp;gt; &amp;quot;identifier&amp;quot;&amp;quot;&amp;quot; =&amp;gt; &amp;quot;&amp;quot;学到的 新知识
 正则表达式的 $1 - $9 正则表达式之先行断言 str.replace()的参数  复习
 replace() charCodeAt()  my solution 思路：用正则拿到大写，再用split(..)以大写字母为界切开，然后在头部加上大写字母，然后拼接在一起。
使用的方法: 正则 match(/[A-Z]/g), split, slice, concat, join, push &amp;hellip;
我真的想得太复杂了
function breakCamel(words) { if (words === &amp;#34;&amp;#34;) { return &amp;#39;&amp;#39; } else { // 得出这组字符串中大写字母 []  let uppercase = words.</description>
    </item>
    
    <item>
      <title>力扣 oh Leetcode</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/my-miserable-leetcode/</link>
      <pubDate>Wed, 18 May 2022 11:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/my-miserable-leetcode/</guid>
      <description>作为一个准前端开发者，我天真地以为不用看力扣，你只是个切图仔。但感受到各方各界的暗示：你得看，你得看看。
好吧，其实是快要机考了。
从网上搜的机考真题来看，貌似是3道算法题，难度也许在力扣简单-中等之间。对于一个月前才知道 codewars 这个可爱网站的我来说，不啻晴天霹雳，于是我跑到力扣大概看了几道简单的题目。
第一题很“简单”，只用一个了一个JS的方法就可以计算出来。查看他人的解题，发现大家的思路很不一样，甚至很陌生。这些新奇的思路（不用库）大概就是传说中的算法吧。
啊，算法，犹如哥伦布一脚踏进美洲，还以为是另一个印度呢。
 已了解/未了解：  二分算法 哈希算法 滑动窗口 左右双指针 棧   左右双指针 判断str是否为回文字符串  指针解法  function judge(str) { let left = 0; let right = str.length - 1; if (str.length === 0) return false; while (left &amp;lt;= right) { if (str[left] !== str[right]) { return false } else { left++; right--; } } return true; }  循环解法  function judge(str) { for (let i = 0; i &amp;lt; Math.</description>
    </item>
    
    <item>
      <title>JavaScript 中 this 的绑定</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/this-and-context/</link>
      <pubDate>Fri, 13 May 2022 22:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/this-and-context/</guid>
      <description>this会在执行的上下文中绑定一个对象，有时候绑定全局对象，有时绑定的是某个对象，所以在什么情况下进行什么绑定，比较迷惑。
先说结论：this的绑定取决于函数的直接调用位置。
1. 调用位置 首先要理解什么是调用位置：调用位置就是函数在代码中调用的位置，而不是函数声明的位置。
function foo{ console.log(&amp;#39;foo&amp;#39;); bar(); // &amp;lt;-- bar()的调用位置 } function bar{ console.log(&amp;#39;bar&amp;#39;); baz(); // &amp;lt;-- baz()的调用位置 } function baz{ console.log(&amp;#39;baz&amp;#39;); } foo(); // &amp;lt;-- foo()的调用位置 2. 绑定规则 判断this是如何绑定，首先找到函数的调用位置，然后对比下面的规则，看符合哪一条，且这些规则具有不同的优先级。
2.1 默认绑定 首先，最常用的函数调用类型是：独立函数调用。这条规则可以看作是不符合其他规则时的默认规则。
场景 1：独立函数的调用 因为this没有绑定到任何对象，所以默认绑定到全局。
function foo() { console.log(this.a); } const a = 2; foo(); // 2 场景 2：将函数作为参数传入另一个函数时 这样的绑定，本质上仍然是独立函数的调用。
function foo(fn) { fn(); } function bar() { console.log(this.a); // window } var a = 8; foo(bar); // 8 但，如果使用let和const，或是严格模式下，隐式绑定会丢失。</description>
    </item>
    
    <item>
      <title>如何优雅地用 JS 创建包含 0 ~ n 的整数数组</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/js-create-number-array/</link>
      <pubDate>Sat, 23 Apr 2022 15:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/js-create-number-array/</guid>
      <description>Codewar 上有一题非常简单的题：
 写一个函数，给任意一个正整数 n，求和。
 Example:
2 -&amp;gt; 1 + 2 // output: 35 -&amp;gt; 1 + 2 + 3 + 4 + 5 // output: 15【小学生解法】
先用小学就学过等差数列的累加计算公式“( 首项 + 末项 ) * 项数 / 2”计算一下:
2 -&amp;gt; (1+2)* 2/2 = 3 ✔5 -&amp;gt; (1+5)* 5/2 = 15 ✔本小学生做对了！
【用 for 循环】
也很容易想到的是用 for 循环解题：
function sum(n) { let sum = 0; for (i = 0; i &amp;lt;= n; i++) { sum += i; } return sum; }  其实像这种累加的题目，感觉非常适合用 reduce 来做，于是问题变成了如何快速创建一个 0~n 的数组？</description>
    </item>
    
    <item>
      <title>ES6数组与对象的解构赋值</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/variable-destructuring/</link>
      <pubDate>Sun, 28 Nov 2021 15:23:00 +0900</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/variable-destructuring/</guid>
      <description>在ES6以前，为变量赋值只能直接指定值，而ES6允许以变量解构的方式赋值。
那么，何为解构？
 按照一定模式，从数组和对象中提取值，对变量进行赋值。 —— （变量的解构赋值 - 阮一峰ES6入门）
 1. 数组解构 数组解构允许我们按照一一对应的关系从数组中提取然后将值赋值给变量：
let arr = [1, 2, 3]; let [a, b, c] = arr; console.log(a); console.log(b); console.log(b); //输入结果分别为 1, 2, 3 情况1：完全匹配 let [a, b, c] = [1, 2, 3];
情况2：部分匹配 let [x, y] = [1, 2, 3]; x // 1 y // 2  let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 例子：codewar上有一道题：求一组正整数中的两个最小值的和。</description>
    </item>
    
    <item>
      <title>let &amp; const 对比 var 的新特性</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/let-n-const/</link>
      <pubDate>Fri, 26 Nov 2021 22:13:01 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/let-n-const/</guid>
      <description>let  let 关键字用于声明变量 用 let 声明的变量具有块级作用域，var 则没有，这可以阻止循环变量变成全局变量  var a = []; for (var i = 0; i &amp;lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 //i因为由var声明，所以是全局变量，经过循环后，i= 10，所以结果都为10 var a = []; for (let i = 0; i &amp;lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 //如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6  不存在变量提升：必须先声明，再使用 不能重复声明  let a = 0; let a; // Uncaught SyntaxError: Identifier &amp;#39;a&amp;#39; has already been declared  用 let 声明的变量具有暂时性死区(Temporal Dead Zone):   ES6 规定，let/const 命令会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。</description>
    </item>
    
  </channel>
</rss>
