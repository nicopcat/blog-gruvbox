<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on Nic Tian</title>
    <link>http://blog.nekolas.cafe/tags/javascript/</link>
    <description>Recent content in JavaScript on Nic Tian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 May 2022 14:00:00 +0800</lastBuildDate><atom:link href="http://blog.nekolas.cafe/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>codewars练习</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/codewars/</link>
      <pubDate>Sat, 21 May 2022 14:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/codewars/</guid>
      <description>开个帖子记录一下解题和方法。
Break camelCase Details
 Complete the solution so that the function will break up camel casing, using a space between words.
 Example
&amp;quot;camelCasing&amp;quot; =&amp;gt; &amp;quot;camel Casing&amp;quot;&amp;quot;identifier&amp;quot; =&amp;gt; &amp;quot;identifier&amp;quot;&amp;quot;&amp;quot; =&amp;gt; &amp;quot;&amp;quot;学到的 新知识
 正则表达式的 $1 - $9 正则表达式之先行断言 str.replace()的参数  复习
 replace() charCodeAt()  my solution 思路：用正则拿到大写，再用split(..)以大写字母为界切开，然后在头部加上大写字母，然后拼接在一起。
使用的方法: 正则 match(/[A-Z]/g), split, slice, concat, join, push &amp;hellip;
我真的想得太复杂了
function breakCamel(words) { if (words === &amp;#34;&amp;#34;) { return &amp;#39;&amp;#39; } else { // 得出这组字符串中大写字母 []  let uppercase = words.</description>
    </item>
    
    <item>
      <title>力扣 oh Leetcode</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/my-miserable-leetcode/</link>
      <pubDate>Wed, 18 May 2022 11:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/my-miserable-leetcode/</guid>
      <description>作为一个准前端开发者，我天真地以为不用看力扣，你只是个切图仔。但感受到各方各界的暗示：你得看，你得看看。
好吧，其实是快要机考了。
从网上搜的机考真题来看，貌似是3道算法题，难度也许在力扣简单-中等之间。对于一个月前才知道 codewars 这个可爱网站的我来说，不啻晴天霹雳，于是我跑到力扣大概看了几道简单的题目。
第一题很“简单”，只用一个了一个JS的方法就可以计算出来。查看他人的解题，发现大家的思路很不一样，甚至很陌生。这些新奇的思路（不用库）大概就是传说中的算法吧。
啊，算法，犹如哥伦布一脚踏进美洲，还以为是另一个印度呢。
 已了解/未了解：  二分算法 哈希算法 滑动窗口 左右双指针   题目： 判断str是否为回文字符串 来自牛客网 左右双指针：
function judge(str) { let left = 0; let right = str.length - 1; if (str.length === 0) return false; while (left &amp;lt;= right) { if (str[left] !== str[right]) { return false } else { left++; right--; } } return true; } 循环：
function judge(str) { for (let i = 0; i &amp;lt; Math.</description>
    </item>
    
    <item>
      <title>JavaScript 中 this 的绑定</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/this-and-context/</link>
      <pubDate>Fri, 13 May 2022 22:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/this-and-context/</guid>
      <description>this会在执行的上下文中绑定一个对象，有时候绑定全局对象，有时绑定的是某个对象，所以在什么情况下进行什么绑定，比较迷惑。
先说结论：this的绑定取决于函数的直接调用位置。
1. 调用位置 首先要理解什么是调用位置：调用位置就是函数在代码中调用的位置，而不是函数声明的位置。
function foo{ console.log(&amp;#39;foo&amp;#39;); bar(); // &amp;lt;-- bar()的调用位置 } function bar{ console.log(&amp;#39;bar&amp;#39;); baz(); // &amp;lt;-- baz()的调用位置 } function baz{ console.log(&amp;#39;baz&amp;#39;); } foo(); // &amp;lt;-- foo()的调用位置 2. 绑定规则 判断this是如何绑定，首先找到函数的调用位置，然后对比下面的规则，看符合哪一条，且这些规则具有不同的优先级。
2.1 默认绑定 首先，最常用的函数调用类型是：独立函数调用。这条规则可以看作是不符合其他规则时的默认规则。
场景 1：独立函数的调用 因为this没有绑定到任何对象，所以默认绑定到全局。
function foo() { console.log(this.a); } const a = 2; foo(); // 2 场景 2：将函数作为参数传入另一个函数时 这样的绑定，本质上仍然是独立函数的调用。
function foo(fn) { fn(); } function bar() { console.log(this.a); // window } var a = 8; foo(bar); // 8 但，如果使用let和const，或是严格模式下，隐式绑定会丢失。</description>
    </item>
    
    <item>
      <title>如何优雅地用 JS 创建包含 0 ~ n 的整数数组</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/js-create-number-array/</link>
      <pubDate>Sat, 23 Apr 2022 15:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/js-create-number-array/</guid>
      <description>Codewar 上有一题非常简单的题：
 写一个函数，给任意一个正整数 n，求和。
 Example:
2 -&amp;gt; 1 + 2 // output: 35 -&amp;gt; 1 + 2 + 3 + 4 + 5 // output: 15【小学生解法】
先用小学就学过等差数列的累加计算公式“( 首项 + 末项 ) * 项数 / 2”计算一下:
2 -&amp;gt; (1+2)* 2/2 = 3 ✔5 -&amp;gt; (1+5)* 5/2 = 15 ✔本小学生做对了！
【用 for 循环】
也很容易想到的是用 for 循环解题：
function sum(n) { let sum = 0; for (i = 0; i &amp;lt;= n; i++) { sum += i; } return sum; }  其实像这种累加的题目，感觉非常适合用 reduce 来做，于是问题变成了如何快速创建一个 0~n 的数组？</description>
    </item>
    
    <item>
      <title>好玩的JavaScrip动画框架——GSAP 【intro部分试译】</title>
      <link>http://blog.nekolas.cafe/posts/tech/others/gsap-intro/</link>
      <pubDate>Sat, 12 Mar 2022 13:00:00 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/others/gsap-intro/</guid>
      <description>GSAP 全称是 GreenSock Animation Platform，是一个非常强大的基于 JS 的动画库，初次接触的我深感，短短几行代码就能实现非常酷炫的特效。
在学习的过程中，顺便把官网的教程翻译成中文参考。
什么是 GSAP? GSAP 其实是在操控属性 动画最终可以归结为一个每秒多次改变属性值的过程，可以使某物产生移动、褪色、旋转等效果。GSAP 抓取一个起始值和一个终止值，然后每秒在它们之间插值 60 次。
例如，在 1 秒内将一个物体的 X 坐标从 0 改变到 1000，并使其迅速向右移动。将不透明度从 1 到 0 渐变，使一个元素淡出。作为一个动画师，你的任务是决定改变哪些属性，多快，以及运动的风格（即缓动&amp;ndash;我们后面会讲到）。
DOM, SVG, &amp;lt;canvas&amp;gt; 以及其他 GSAP 并没有预定义它可以处理哪些属性。它超级灵活，几乎可以适应你扔给它的任何东西。GSAP 可以对以下所有内容进行动画处理：
 CSS: 2D and 3D transforms, colors, width, opacity, border-radius, margin, and 几乎所有的 CSS 属性 SVG 属性: viewBox, width, height, fill, stroke, cx, r, opacity, etc. 像 MorphSVG 和 DrawSVG 这样的插件可以用于高级效果 任何数值 例如，一个被渲染到&amp;lt;canvas&amp;gt;的对象。对三维场景中的相机位置进行动画处理，或对数值进行过滤。GSAP 经常与 Three.js 和 Pixi.</description>
    </item>
    
    <item>
      <title>ES6数组与对象的解构赋值</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/variable-destructuring/</link>
      <pubDate>Sun, 28 Nov 2021 15:23:00 +0900</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/variable-destructuring/</guid>
      <description>在ES6以前，为变量赋值只能直接指定值，而ES6允许以变量解构的方式赋值。
那么，何为解构？
 按照一定模式，从数组和对象中提取值，对变量进行赋值。 —— （变量的解构赋值 - 阮一峰ES6入门）
 1. 数组解构 数组解构允许我们按照一一对应的关系从数组中提取然后将值赋值给变量：
let arr = [1, 2, 3]; let [a, b, c] = arr; console.log(a); console.log(b); console.log(b); //输入结果分别为 1, 2, 3 情况1：完全匹配 let [a, b, c] = [1, 2, 3];
情况2：部分匹配 let [x, y] = [1, 2, 3]; x // 1 y // 2  let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 例子：codewar上有一道题：求一组正整数中的两个最小值的和。</description>
    </item>
    
    <item>
      <title>let &amp; const 对比 var 的新特性</title>
      <link>http://blog.nekolas.cafe/posts/tech/javascript/let-n-const/</link>
      <pubDate>Fri, 26 Nov 2021 22:13:01 +0800</pubDate>
      
      <guid>http://blog.nekolas.cafe/posts/tech/javascript/let-n-const/</guid>
      <description>let  let 关键字用于声明变量 用 let 声明的变量具有块级作用域，var 则没有，这可以阻止循环变量变成全局变量  var a = []; for (var i = 0; i &amp;lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 //i因为由var声明，所以是全局变量，经过循环后，i= 10，所以结果都为10 var a = []; for (let i = 0; i &amp;lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 //如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6  不存在变量提升：必须先声明，再使用 不能重复声明  let a = 0; let a; // Uncaught SyntaxError: Identifier &amp;#39;a&amp;#39; has already been declared  用 let 声明的变量具有暂时性死区(Temporal Dead Zone):   ES6 规定，let/const 命令会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。</description>
    </item>
    
  </channel>
</rss>
